# Network
* * *
### Nagle Algorithm

> 가능하면 조금씩 여러번 보내지 말고 한번에 많이 보내라(Effective TCP)

 전송해야할 데이터가 있는데, 상대방의 윈도우 크기가 매우 작은 경우, 내가 의도하진 않았짐나 보낼 수 있는 세그먼트의 크기 자체가 작기 때문에 따로 지연 설정을 하지 않으면, 작은 크기의 세그먼트가 만들어질 수밖에 없다. 보낼 수 있는 데이터를 바로 세그먼트로 만들지 않고, 가능한 모아서 더 큰 세그먼트로 만들어 한번에 보내면 이런 문제는 발생하지 않을 것이다. 네이글 알고리즘은 이 대안을 실제로 구현한 네트워크 전송 알고리즘이다.

  Segment의 최대 크기는 1460byte이다. 이것을 꽉 채워서 보내는게 좋을텐데 어떻게 하면 그럴 수 있을까. 알고리즘은 다음과 같다

- 처음에 데이터가 들어오면 데이터 크기와 상관없이 일단 보낸다.
- 두번째부터는
  - ACK가 도착했을 경우, 쌓인 데이터를 보낸다.
  - Segment 크기만큼 데이터가 쌓일 경우, 데이터를 보낸다.
- 두번째를 계속 반복한다.

### TCP Connection

  3-way handshake. 즉 세그먼트가 세 번 교환됨으로써 커넥션이 이루어진다. 2-way로 하면 왜 안될까.  클라이언트가 연결하자고 요청하면 서버가 대답하는 것이 2-way일 것인데, 서버의 대답이 도착한다는 보장이 없다. 

#### 3-way handshake

![three way handshake에 대한 이미지 검색결과](https://learningnetwork.cisco.com/resources/statics/1219267/av440f1_transport_p1_q2_poster.jpg)

 처음에 클라이언트가 SYN bit를 1로해서 보낸다. 서버가 tcp connection할 의향이 있으면 응답을 보낸다. SYNACK SYN bit이 1이면서 ACK를 보낸다. 그러면 다시 클라이언트는 받아서 ACK를 보낸다.

#### termination

![four way handshake에 대한 이미지 검색결과](https://t1.daumcdn.net/cfile/tistory/2336285058D7288E33)

 클라이언트가 더 이상 보낼 것이 없는 경우, FIN bit을 1로 보낸다. 서버는 ack를 보내고 난 후, 서버가 보내야 할 데이터 다 보낸 후에 FIN  bit을 1로 보낸다. 클라이언트도 여기에 대해서 ack를 보낸다. 클라이언트는 보내고 마지막 ack를 보낸 후 바로 끝나는 것이 아니라 아직 연결상태를 기다려야 한다. 마지막 FIN에 대한 ack가 유실될 경우를 대비해서. 

### Subnet Mask

#### Subnet이란

IP 주소는 Network ID, Host ID로 나뉜다. Network id를 Subnet이라고 부르기도 한다. 그래서 Ip는 subnet 파트, host 파트로 나뉜다. Subnet은 어떤 디바이스의 집합니다. 공통된 서브넷 주소를 가지고 있는 디바이스의 집합. 같은 서브넷에 존재하는 디바이스끼리는 라우터를 거칠 필요가 없다. 다른 서브넷에 있는 디바이스에 접근하기 위해서는 라우터를 거쳐야 한다. 서브넷은 물리적으로 라우터로 나뉘어 있다. 라우터는 특수한 디바이스이다. 호스트는 하나의 서브넷에 속해있지만 라우터는 여러 개의 서브넷에 속해있다. 그래서 자신이 속한 서브넷을 포워딩하는 역할을 한다.

![1569997667245](C:\Users\multicampus\AppData\Roaming\Typora\typora-user-images\1569997667245.png)

 여기서 서브넷은 총 6개이다. 라우터의 개수만큼 서브넷을 건너야 한다.

#### Subnet Mask

 IP주소가 있으면 서브넷 부분만 1로 만든다. xxx.xxx.xxx.xxx / 24 인 경우, 서브넷마스크는 11111111 11111111 11111111 00000000 이 된다. 그래서 IP주소와 and 연산하여 서브넷 부분만 쏙 빼내어 forwarding table과 비교한다.

### OSI 7 Layer : 물데네전세표응

하위계층 : 물리 -> 데이터링크 -> 네트워크
상위계층 : 전송 -> 세션 -> 표현 -> 응용

#### Physical Layer

 시스템의 전기적, 물리적 표현을 나타낸다. 케이블 종류, 무선 주파수 링크는 물론 핀 배치, 전압, 물리 요건 등이 포함된다. 네트워킹 문제가 발생하면 많은 네트워크 전문가가 물리 계층으로 바로 가서 모든 케이블이 제대로 연결돼 있는지, 라우터나 스위치 또는 컴퓨터에서 전원 플러그가 빠지지 않았는지 확인한다. 

 사용되는 통신 단위는 비트이며 이것은 1, 0의 전기적 신호로 나타낸다. 단지 데이터를 전기적인 신호로 변환해서 주고받는 기능만 할 뿐이다. 대표적으로는 통신 케이블, 리피터, 허브 등이 있다.

##### 리피터

 근접한 2개 이상의 데이터 네트워크간 신호를 전송하며 리피터는 신호를 재생하고 복사하는 장비이다. 데이터가 전송되는 동안 케이블에서는 신호의 손실인 감쇄 현상이 일어나는데 리피터는 감쇄되는 신호를 증폭하고 재생하여 전송하는 역할을 한다. IP주소나 MAC 주소를 이해하지 못한다.

##### 허브

 전기적인 신호를 증폭시켜 LAN의 전송거리를 연장시키고 여러대의 장비를 LAN에 접속할 수 있도록 한다. UTP 케이블을 사용하는 환경에서 장비들을 상호 연결시키는 콘센트레이터 역할도 함께 제공한다. 한 장비에서 전송된 데이터 프레임을 허브로 연결된 모든 장비에게 다 전송하는 플러딩이 발생한다.

#### Data Link Layer

 데이터 링크 계층은 두 개의 직접 연결된 노드 사이의 노드간 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다. 2개의 부계층이 존재하는데 하나는 매체 접근 제어(MAC) 계층이고 다른 하나는 논리적 연결 제어(LLC) 계층이다. 네트워킹 세계에서 대부분 스위치는 2계층에서 작동한다.

##### 프레이밍

 데이터를 프레임으로 그룹화하여 전송한다. 데이터 배열에 Data, Header, Trailer 등을 넣어 캡슐화하는 작업이다. 각 노드에서 다음 노드로 데이터를 보낼 때, 네트워크 레이어에서 받은 데이터그램을 캡슐화하는 작업이다. 그리고 캡슐화된 틀(데이터배열)을 프레임이라고 한다.

##### 흐름제어

 송신자와 수신자의 처리 속도 차이를 해결하기 위한 제어. 송신 측이 수신 측 데이터 처리 속도보다 훨씬 빠른 속도로 데이터를 보내면 수신 측의 버퍼가 점점 길어질 것이다. 이를 방지하기 위해 수신 측에서 송신 측에게 그만 보내거나 천천히 보내라는 피드백을 보낼 수 있는데, 이것을 흐름제어라고 한다.

##### 에러제어

 송신 측에서 Framing을 하고 이것을 0과 1로 이루어진 비트로 변환하고 보낸다. 수신 측에서 당연히 이 비트 배열을 받을텐데, 0과 1로 이루어진 전기적 신호들이 매우 취약하기 때문에 수신 측의 데이터 링크 계층에서 에러를 감지하는 역할을 한다. 두 가지 방법이 있다. 1) 에러를 직접 수정(해밍코드) 2) Frame 폐기 후 재송신 요청.

##### 순서제어

 패킷이나 ACK 신호를 잘못 혼동하는 것을 피하기 위해 패킷과 ACK 신호 안에 Sequence number가 부여되어야 한다. 이것으로 순서제어 ㄱㄱ.

##### ARP(Address Resolution Protocol)

 우리는 IP주소를 통해 인터넷 상 본인의 정확한 위치를 알려줄 수 있다. 그러나 일반적으로 송신자와 수신자가 직접 연결된 것이 아니라 라우터와 서버로 연결되어 있다. 중간에 거쳐야할 정거장이 많다. 그래서 라우터를 통해 데이터를 보내주어야 한다. 

 전기적 신호는 IP가 아닌 MAC 주소를 따라 흐른다. 수신측으로 향하는 길의 중간에 있는 노드들의 MAC 주소가 필요하다. 이 때 유용한 기술이 ARP이다. ARP는 네트워크 상에서 IP주소를 MAC 주소로 대응(bind)시키기 위해 사용되는 프로토콜이다.

같은 네트워크 망일 경우,
 송신자는 수신자의 MAC주소가 알고싶다. 그러나 송신자가 알고있는 것은 IP주소밖에 없다. 그래서 송신자는 Broadcast Address를 이용해서 모든 노드에게 특정 IP주소를 가지고 있는 노도는 MAC 주소를 송신자 측에게 보내라고 한 것이다. 그러면 특정 IP주소를 가지고 있는 노드는 MAC주소를 전송하고 서로 IP주소와 MAC 주소를 알 수 있게 된다. MAC 주소는 직접 연결된 범위(스위치, 허브, 라우터 등)에서만 사용할 수 있다.

다른 네트워크 망일 경우,
 송신자는 수신자가 자신의 대역과 다르다는 것을 알았다. 송신자는 라우터의 MAC 주소를 알아내어 Default Gateway로 지정한다. 그리고 라우터에게 수신자와 통신하고 싶다고 말한다. 그리고 보낼 데이터를 라우터에 보내면 된다. 송신자가 수신자와 통신하기 위해 수신자의 MAC 주소를 알 필요가 없게 된다. Default Gateway는 라우팅을 통해 송신자에게 패킷을 보낸다. 출발지 IP는 송신자이지만 출발지 MAC주소는 Default Gateway MAC 주소이다. 송신자 측의 네트워크에 패킷이 도착하면 ARP를 통해 D의 MAC주소를 알아낸 뒤 송신자에게 패킷을 전달한다.[^1]

#### Network Layer

 이 계층에서 가장 중요한 기능은 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)이다. 여기에 사용되는 프로토콜의 종류도 다양하고, 라우팅하는 기술도 다양하다. 이 계층은 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 역할을 한다. 대표적인 장비는 라우터이며 2계층의 스위치에 라우팅 기능을 장착한 L3 스위치도 있다.

 라우팅, 흐름제어, 세그멘테이션, 오류제어, 인터네트워킹 등을 수행한다.

#### Transport Layer

#### Session Layer

  상위 계층에 제공하는 서비스로 세션 연결 설정과 해제, 세션 메시지 전송을 통해 동작한다. 크게 동기기능과 대화 기능을 수행한다. 2대의 기기, 컴퓨터 또는 서버 간에 대화가 필요하면 세션을 만들어야 하는데 이 작업이 여기서 처리된다.[^2]

##### 동기기능

 통신 양단끼리 서로 동의하는 논리적인 공통 시점인 동기점을 만들어 메시지가 제대로 처리되고 있는지 파악한다. 동기점은 오류 복구를 위하여 필수적으로 사용되는데 동기점 설정 이전까지는 서로 처리가 완료되었음을 합의하는 역할을 한다. 동기점 이전까지는 복구할 필요가 없고, 동기점 이후 처리 과정에 대한 복구 절차가 진행된다. 

##### 대화기능

 대화는 데이터 전송 과정을 의미한다. 시간 경과에 따라 순차적으로 동기점을 부여하여 신뢰성 보장 기능을 단계적으로 구현할 수 있게 된다. 대화를 관리하기 위해 토큰이라는 특수 메시지를 사용한다. 토큰을 가지고 있다는 것은 해당 토큰에 부여된 특정 권리를 배타적으로 소유한다는 의미를 가진다. 권한으로는 데이터를 전송할 수 있는 권한, 통신 양단 사이 연결을 해제하는 권한 등이 있다.

 큰 파일 전체를 하나의 단위로 전송하는 것보다 논리적으로 작은 단위로 나누어서 전송하는 것이 오류 발생 시 유리하다. 오류가 발생하면 오류가 난 부분부터 다시 보내면 되기 때문이다. 그래서 동기점이 중요하다. 

#### Presentation Layer

 응용 계층의 데이터 표현에서 독립적인 부분을 나타낸다. 응용프로그램 형식을 준비 또는 네트워크 형식으로 변환하거나 네트워크 형식을 응용프로그램 형식으로 변환하는 것을 나타낸다. 응용프로그램이나 네트워크를 위해 데이터를 표현하는 것이다. 대표적인 예로 데이터 암호화, 복호화 등이 있다.

#### Application Layer

 사용자에게 보이는 부분이다. 응용프로그램은 사용자와 직접적으로 상호작용한다. 브라우저와 응용 프로그램이 대표적인 예이다. HTTP, FTP, SMTP, TELNET 등과 같은 프로토콜이 있다.

### Parity Bit

![img](https://mblogthumb-phinf.pstatic.net/MjAxNjEyMTVfNDgg/MDAxNDgxNzc4Mjg0NTk2.Ln8Hqrvkg1KjguXpEf9ISN9Cqijkg7rnvu0JUjMJ4Dwg.HCbNEziV16sQvFmbRAPsVzZrvYCQqtV6H6QjYuqFP70g.PNG.ansdbtls4067/%EA%B7%B8%EB%A6%BC5.png?type=w800)

#### Even Parity(짝수 패리티)

 짝수 패리티는 실제 송신하고자 하는 데이터의 각 비트의 값 중에서 1의 개수가 짝수가 되도록 패리티 비트를 정하는 것이다. 데이터 비트에서 1의 개수가 짝수이면 1로 정하고 짝수개이면 0으로 정한다.

#### Odd Parity(홀수 패리티)

 홀수 패리티는 전체 비트에서 1의 개수가 홀수가 되도록 패리티 비트를 정하는 방법이다. 1의 개수가 홀수개이면 0, 짝수개이면 1이 된다.

#### 특징

 데이터를 송수신하는 과정에서 각 비트를 단위시간당 하나씩 보내게 되어있는데, 이 때 알수없는 요인에 의해서 비트의 값이 틀어져 1이 0으로 바뀌거나 0이 1로 바뀌었을 때 이를 확인할 수 있다.

 다만 오류 발생 여부를 알 수 있지 오류 수정을 할 수 있다는 것은 아니다. 데이터 손실을 인지하고, 수신 호스트에서 송신 호스트로 재전송 요청을 할 수 있도록 보다 안정적인 통신을 제공하는 수단이다.

 보통은 Checksum을 이용하고, 패리티 비트는 통신의 거리가 상당히 멀 경우에 주로 적용된다.